-- üîÅ –ê–í–¢–û–§–ê–†–ú: –°—Ç–∞–≤–∏—Ç, –∞–ø–≥—Ä–µ–π–¥–∏—Ç, —Ä–µ—Å—Ç–∞—Ä—Ç–∏—Ç
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local entityFolder = workspace:WaitForChild("Map"):WaitForChild("Entities")
local cash = player:WaitForChild("leaderstats"):WaitForChild("Cash")

local restarting = false

-- üîß –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —Å—Ç—Ä–æ–∫–∏ –¥–µ–Ω–µ–≥
local function parseCash(val)
    if not val then return 0 end
    val = tostring(val):gsub(",", "")
    if val:lower():find("k") then
        local num = tonumber(val:lower():gsub("k", ""))
        return (num or 0) * 1000
    end
    return tonumber(val) or 0
end

-- üí∞ –û–∂–∏–¥–∞–µ–º –Ω—É–∂–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ–Ω–µ–≥ –∏–ª–∏ —Ä–µ—Å—Ç–∞—Ä—Ç
local function waitForCash(amount)
    repeat wait(0.2) until parseCash(cash.Value) >= amount or restarting
end

-- üì¶ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —é–Ω–∏—Ç–∞ –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –µ–≥–æ ID
local function placeUnitAndGetId(unitName, position)
    local before = {}
    for _, v in pairs(entityFolder:GetChildren()) do before[v] = true end

    local cf = CFrame.new(position) * CFrame.Angles(0, math.rad(180), 0)
    ReplicatedStorage.RemoteFunctions.PlaceUnit:InvokeServer(unitName, {
        Valid = true,
        Position = position,
        CF = cf,
        Rotation = 180
    })

    for _ = 1, 50 do
        wait(0.1)
        for _, v in pairs(entityFolder:GetChildren()) do
            if not before[v] and v:IsA("Model") and v:GetAttribute("ID") then
                return v:GetAttribute("ID")
            end
        end
    end
    return nil
end

-- ‚¨ÜÔ∏è –ê–ø–≥—Ä–µ–π–¥ —é–Ω–∏—Ç–∞ –ø–æ —É–∫–∞–∑–∞–Ω–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏—è–º
local function upgradeAtCash(unitId, upgradeSteps)
    for _, cost in ipairs(upgradeSteps) do
        waitForCash(cost)
        if restarting then return end
        ReplicatedStorage.RemoteFunctions.UpgradeUnit:InvokeServer(unitId)
    end
end

-- üß† –ê–≤—Ç–æ–≤—ã–±–æ—Ä —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
local function autoVoteDifficulty(mode)
    local difficultyMap = {
        ["Easy"] = "dif_easy",
        ["Normal"] = "dif_normal",
        ["Hard"] = "dif_hard",
        ["Insane"] = "dif_insane",
        ["Impossible"] = "dif_impossible"
    }
    local arg = difficultyMap[mode or "Insane"] or "dif_insane"
    local gui = player:WaitForChild("PlayerGui")

    task.spawn(function()
        while true do
            wait(0.2)
            local voteUI = gui:FindFirstChild("GameGui")
                and gui.GameGui:FindFirstChild("Screen")
                and gui.GameGui.Screen:FindFirstChild("Middle")
                and gui.GameGui.Screen.Middle:FindFirstChild("DifficultyVote")
            if voteUI and voteUI.Visible then
                ReplicatedStorage.RemoteFunctions.PlaceDifficultyVote:InvokeServer(arg)
                break
            end
        end
    end)
end

-- üîÅ –ù–∞–±–ª—é–¥–µ–Ω–∏–µ –∑–∞ –∫–Ω–æ–ø–∫–æ–π Play Again
task.spawn(function()
    local gui = player:WaitForChild("PlayerGui")
    while true do
        wait(1)
        local btn = gui:FindFirstChild("GameGui")
            and gui.GameGui:FindFirstChild("Screen")
            and gui.GameGui.Screen:FindFirstChild("Middle")
            and gui.GameGui.Screen.Middle:FindFirstChild("GameEnd")
            and gui.GameGui.Screen.Middle.GameEnd:FindFirstChild("Items")
            and gui.GameGui.Screen.Middle.GameEnd.Items:FindFirstChild("Frame")
            and gui.GameGui.Screen.Middle.GameEnd.Items.Frame:FindFirstChild("Actions")
            and gui.GameGui.Screen.Middle.GameEnd.Items.Frame.Actions:FindFirstChild("Items")
            and gui.GameGui.Screen.Middle.GameEnd.Items.Frame.Actions.Items:FindFirstChild("Again")

        if btn and btn.Visible then
            restarting = true
            ReplicatedStorage.RemoteFunctions.RestartGame:InvokeServer()
        end
    end
end)

-- üîÑ –û–¥–∏–Ω —Ü–∏–∫–ª –∫–∞—Ç–∫–∏
local function runMatch()
    wait(1)
    ReplicatedStorage.RemoteFunctions.RestartGame:InvokeServer()
    autoVoteDifficulty("Insane")
    wait(1)
    restarting = false

    local function safePlaceAndUpgrade(name, pos, upgrades)
        waitForCash(upgrades[1] or 1000)
        if restarting then return end
        local id = placeUnitAndGetId(name, pos)
        if id then upgradeAtCash(id, upgrades) end
    end

    -- 1‚Äì3: —Ñ–µ—Ä–º–µ—Ä—ã
    safePlaceAndUpgrade("unit_farmer_npc", Vector3.new(-332.14, 63.38, -77.40), {250, 350, 500})
    safePlaceAndUpgrade("unit_farmer_npc", Vector3.new(-338.47, 63.38, -77.79), {250, 350, 500})
    safePlaceAndUpgrade("unit_farmer_npc", Vector3.new(-338.30, 63.38, -83.23), {250, 350, 500})

    -- 4: –ø—Ä–æ—Å—Ç–æ —Å—Ç–∞–≤–∏–º beehive
    waitForCash(2500)
    if restarting then return end
    placeUnitAndGetId("unit_beehive", Vector3.new(-330.08, 63.46, -99.32))

    -- 5‚Äì6: –∞–ø–≥—Ä–µ–π–¥–∏–º beehive
    safePlaceAndUpgrade("unit_beehive", Vector3.new(-323.65, 63.46, -98.40), {1500, 4000, 10000, 25000})
    safePlaceAndUpgrade("unit_beehive", Vector3.new(-324.86, 63.46, -91.45), {1500, 4000, 10000, 25000})

    -- 7‚Äì9: pulse
    safePlaceAndUpgrade("unit_pulse_plant", Vector3.new(-325.80, 63.94, -78.21), {3000, 7500, 10000, 25000})
    safePlaceAndUpgrade("unit_pulse_plant", Vector3.new(-328.13, 63.94, -85.03), {3000, 7500, 10000, 25000})
    safePlaceAndUpgrade("unit_pulse_plant", Vector3.new(-340.26, 63.94, -88.00), {3000, 7500, 10000, 25000})

    -- üßò –ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è ‚Äî –ø—Ä–æ—Å—Ç–æ –∂–¥–µ–º –∫–Ω–æ–ø–∫—É —Ä–µ—Å—Ç–∞—Ä—Ç–∞
    while not restarting do wait(1) end
end

-- üöÄ –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª
while true do
    runMatch()
end
