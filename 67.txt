local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local entityFolder = workspace:WaitForChild("Map"):WaitForChild("Entities")
local cash = player:WaitForChild("leaderstats"):WaitForChild("Cash")

local restarting = false
local autoSkipEnabled = false

-- üí∞ –ü–∞—Ä—Å–∏–Ω–≥ –¥–µ–Ω–µ–≥
local function parseCash(val)
    if not val then return 0 end
    val = tostring(val):gsub(",", "")
    if val:lower():find("k") then
        local num = tonumber(val:lower():gsub("k", ""))
        return (num or 0) * 1000
    end
    return tonumber(val) or 0
end

-- ‚è≥ –ñ–¥—ë–º –Ω—É–∂–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ–Ω–µ–≥
local function waitForCash(amount)
    repeat wait(0.2) until parseCash(cash.Value) >= amount or restarting
end

-- üì¶ –°—Ç–∞–≤–∏–º —é–Ω–∏—Ç–∞ –∏ –ø–æ–ª—É—á–∞–µ–º –µ–≥–æ ID
local function placeUnitAndGetId(unitName, position)
    local before = {}
    for _, v in pairs(entityFolder:GetChildren()) do before[v] = true end

    local cf = CFrame.new(position) * CFrame.Angles(0, math.rad(180), 0)
    ReplicatedStorage.RemoteFunctions.PlaceUnit:InvokeServer(unitName, {
        Valid = true,
        Position = position,
        CF = cf,
        Rotation = 180
    })

    for _ = 1, 50 do
        wait(0.1)
        for _, v in pairs(entityFolder:GetChildren()) do
            if not before[v] and v:IsA("Model") and v:GetAttribute("ID") then
                return v:GetAttribute("ID")
            end
        end
    end
    return nil
end

-- ‚¨ÜÔ∏è –ê–ø–≥—Ä–µ–π–¥ –ø–æ —à–∞–≥–∞–º (—Å –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–º —à–∞–≥–∞)
local function upgradeAtCash(unitId, upgradeSteps, onStep)
    for i, cost in ipairs(upgradeSteps) do
        waitForCash(cost)
        if restarting then return end
        ReplicatedStorage.RemoteFunctions.UpgradeUnit:InvokeServer(unitId)
        if onStep then onStep(i) end
    end
end

-- üß† –ê–≤—Ç–æ–≤—ã–±–æ—Ä —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
local function autoVoteDifficulty(mode)
    local arg = ({
        Easy = "dif_easy",
        Normal = "dif_normal",
        Hard = "dif_hard",
        Insane = "dif_insane",
        Impossible = "dif_impossible"
    })[mode or "Insane"] or "dif_insane"

    local gui = player:WaitForChild("PlayerGui")

    task.spawn(function()
        while true do
            wait(0.1)
            local voteUI = gui:FindFirstChild("GameGui")
                and gui.GameGui:FindFirstChild("Screen")
                and gui.GameGui.Screen:FindFirstChild("Middle")
                and gui.GameGui.Screen.Middle:FindFirstChild("DifficultyVote")
            if voteUI and voteUI.Visible then
                ReplicatedStorage.RemoteFunctions.PlaceDifficultyVote:InvokeServer(arg)
                break
            end
        end
    end)
end

-- üîÅ –†–µ—Å—Ç–∞—Ä—Ç, –µ—Å–ª–∏ –∫–Ω–æ–ø–∫–∞ –ø–æ—è–≤–∏–ª–∞—Å—å
task.spawn(function()
    local gui = player:WaitForChild("PlayerGui")
    while true do
        wait(0.2)
        local btn = gui:FindFirstChild("GameGui")
            and gui.GameGui.Screen.Middle.GameEnd.Items.Frame.Actions.Items:FindFirstChild("Again")

        if btn and btn.Visible then
            restarting = true
            autoSkipEnabled = false
            ReplicatedStorage.RemoteFunctions.RestartGame:InvokeServer()
        end
    end
end)

-- üöÄ –ê–≤—Ç–æ—Å–∫–∏–ø –≤–æ–ª–Ω –ø–æ—Å–ª–µ –Ω—É–∂–Ω–æ–≥–æ –∞–ø–≥—Ä–µ–π–¥–∞
task.spawn(function()
    while true do
        wait(0.2)
        if autoSkipEnabled and not restarting then
            ReplicatedStorage.RemoteFunctions.SkipWave:InvokeServer("y")
        end
    end
end)

-- üìç –¢–µ–ª–µ–ø–æ—Ä—Ç –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
local function teleportToStart()
    local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if root then
        root.CFrame = CFrame.new(-80.8577651977539, -29.522750854492188, 215.46897888183594)
    end
end

-- üîÑ –û–¥–∏–Ω –º–∞—Ç—á
local function runMatch()
    wait(1)
    ReplicatedStorage.RemoteFunctions.RestartGame:InvokeServer()
    autoVoteDifficulty("Impossible")
    wait(1)
    teleportToStart()
    restarting = false

    -- 1: Money tree
    waitForCash(300)
    if restarting then return end
    placeUnitAndGetId("unit_money_tree", Vector3.new(-99.56, -27.89, 198.44))

    -- 2: –ü–µ—Ä–≤—ã–π beetroot
    waitForCash(200)
    if restarting then return end
    local beet1 = placeUnitAndGetId("unit_electric_beetroot", Vector3.new(-92.68, -29.52, 225.88))
    if beet1 then upgradeAtCash(beet1, {250, 500, 750}) end

    -- 3: –í—Ç–æ—Ä–æ–π beetroot + –≤–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ—Å–∫–∏–ø –ø–æ—Å–ª–µ –≤—Ç–æ—Ä–æ–≥–æ –∞–ø–≥—Ä–µ–π–¥–∞
    waitForCash(200)
    if restarting then return end
    local beet2 = placeUnitAndGetId("unit_electric_beetroot", Vector3.new(-69.74, -29.52, 226.14))
    if beet2 then
        upgradeAtCash(beet2, {250, 500, 750}, function(step)
            if step == 2 then
                autoSkipEnabled = true
            end
        end)
    end

    -- 4‚Äì6: Beehive —é–Ω–∏—Ç—ã
    local beehiveSteps = {1500, 4000, 10000, 25000}

    waitForCash(2500)
    if restarting then return end
    local b1 = placeUnitAndGetId("unit_beehive", Vector3.new(-91.53, -28.91, 210.04))
    if b1 then upgradeAtCash(b1, beehiveSteps) end

    wait(1)
    waitForCash(2500)
    if restarting then return end
    local b2 = placeUnitAndGetId("unit_beehive", Vector3.new(-86.21, -28.91, 205.25))
    if b2 then upgradeAtCash(b2, beehiveSteps) end

    wait(1)
    waitForCash(2500)
    if restarting then return end
    local b3 = placeUnitAndGetId("unit_beehive", Vector3.new(-86.94, -28.91, 190.88))
    if b3 then upgradeAtCash(b3, beehiveSteps) end

    while not restarting do wait(1) end
end

-- üîÅ –¶–∏–∫–ª
while true do
    runMatch()
end
